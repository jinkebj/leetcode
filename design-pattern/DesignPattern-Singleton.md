# Singleton Pattern - 单例模式

#### 1. 描述

　　保证一个类仅有一个实例，并提供一个访问它的全局访问点。

#### 2. 单例模式主要有3个特点

　　2.1 单例类确保自己只有一个实例。

　　2.2 单例类必须自己创建自己的实例。

　　2.3 单例类必须为其他对象提供唯一的实例。

#### 3. 实现方式：懒汉单例类和饿汉单例类

##### 　　3.1 懒汉式单例类

　　　　对于懒汉模式，我们可以这样理解：该单例类非常懒，只有在自身需要的时候才会行动，从来不知道及早做好准备。它在需要对象的时候，才判断是否已有对象，如果没有就立即创建一个对象，然后返回，如果已有对象就不再创建，立即返回。
　　　　懒汉模式只在外部对象第一次请求实例的时候才去创建。

##### 　　3.2 饿汉式单例类

　　　　对于饿汉模式，我们可以这样理解：该单例类非常饿，迫切需要吃东西，所以它在类加载的时候就立即创建对象。

##### 　　3.3 懒汉模式和饿汉模式的优缺点

　　　　懒汉模式，它的特点是运行时获得对象的速度比较慢，但加载类的时候比较快。它在整个应用的生命周期只有一部分时间在占用资源。

　　　　饿汉模式，它的特点是加载类的时候比较慢，但运行时获得对象的速度比较快。它从加载到应用结束会一直占用资源。

　　　　这两种模式对于初始化较快，占用资源少的轻量级对象来说，没有多大的性能差异，选择懒汉式还是饿汉式都没有问题。但是对于初始化慢，占用资源多的重量级对象来说，就会有比较明显的差别了。所以，对重量级对象应用饿汉模式，类加载时速度慢，但运行时速度快；懒汉模式则与之相反，类加载时速度快，但运行时第一次获得对象的速度慢。

　　　　从用户体验的角度来说，我们应该首选饿汉模式。我们愿意等待某个程序花较长的时间初始化，却不喜欢在程序运行时等待太久，给人一种反应迟钝的感觉，所以对于有重量级对象参与的单例模式，我们推荐使用饿汉模式。

　　　　而对于初始化较快的轻量级对象来说，选用哪种方法都可以。如果一个应用中使用了大量单例模式，我们就应该权衡两种方法了。轻量级对象的单例采用懒汉模式，减轻加载时的负担，缩短加载时间，提高加载效率；同时由于是轻量级对象，把这些对象的创建放在使用时进行，实际就是把创建单例对象所消耗的时间分摊到整个应用中去了，对于整个应用的运行效率没有太大影响。

#### 4. 代码实现：

##### 　　4.1 懒汉式

```c
    public class Singleton
    {
        private static Singleton m_Instance;

        private Singleton()
        {
            // 将默认构造函数定义为私有，防止外部调用它实例化别的对象
        }

        public static Singleton GetInstance()
        {

            if (m_Instance == null)
            {
                m_Instance = new Singleton();
            }

            return m_Instance;
        }
    }
```

##### 　　4.2 饿汉式

```c
    // 定义为sealed防止派生，因为派生可能增加实例
    public sealed class Singleton
    {
        private static readonly Singleton m_Instance = new Singleton();
        private Singleton()
        {
            // 将默认构造函数定义为私有，防止外部调用它实例化别的对象
        }

        public static Singleton GetInstance()
        {
            return m_Instance;
        }
    }
```

#### 5. 模式总结

##### 　　5.1 优点

　　　　防止在应用程序中实例化多个对象。这就节约了开销，每个实例都要占用一定的内存，创建对象时需要时间和空间。

##### 　　5.2 缺点

##### 　　5.3 适用场合

　　　　5.3.1 控制资源的使用，通过线程同步来控制资源的并发访问；

　　　　5.3.2 控制实例产生的数量，达到节约资源的目的。

　　　　5.3.3 作为通信媒介使用，也就是数据共享，它可以在不建立直接关联的条件下，让多个不相关的两个线程或者进程之间实现通信。

##### 　　5.4 对设计原则的支持

　　　　使用单例模式最核心的一点是体现了面向对象封装特性中的“单一职责”原则。

#### 6. 补充

在多线程开放过程中，对使用懒汉单例模式应防止两个线程同时去实例化对象，这是有可能的。下面给出解决方案

##### 　　6.1 使用锁机制

```c
    public class Singleton
    {
        private static Singleton m_Instance;

        static readonly object o = new object();

        private Singleton()
        {
            // 将默认构造函数定义为私有，防止外部调用它实例化别的对象
        }

        public static Singleton GetInstance()
        {
            lock (o)
            {
                if (m_Instance == null)
                {
                    m_Instance = new Singleton();
                }
            }

            return m_Instance;
        }
    }
```
　　使用锁机制可以防止两个线程同时创建对象，但这里有个性能问题，每当一个线程访问GetInstance()这个方法是，都要加锁，这其实是没必要的。

##### 　　6.2 双重锁定

```c
    public class Singleton
    {
        private static Singleton m_Instance;

        static readonly object o = new object();

        private Singleton()
        {
            // 将默认构造函数定义为私有，防止外部调用它实例化别的对象
        }

        public static Singleton GetInstance()
        {
            // 这里增加了一个判断实例是否存在，只有在不存在时才给加锁，也就是在这个实例的生命周期中只加过一次锁
            if (m_Instance == null)
            {
                lock (o)
                {
                    if (m_Instance == null)
                    {
                        m_Instance = new Singleton();
                    }
                }
            }

            return m_Instance;
        }
    }
```
　　双重锁定保证了实例在它的生命周期中只被锁定一次，因而它对性能不会有影响。